using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Protobuf.SourceGenerator
{
    [Generator]
    public class ProtoContractGenerator : IIncrementalGenerator
    {
        private const string ProtoContractAttributeSource = @"
using System;
namespace Protobuf.SourceGenerator
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class ProtoContractAttribute : Attribute { }
}
";

        private const string ProtoMemberAttributeSource = @"
using System;
namespace Protobuf.SourceGenerator
{
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    public sealed class ProtoMemberAttribute : Attribute
    {
        public int FieldNumber { get; }
        public ProtoMemberAttribute(int fieldNumber) { FieldNumber = fieldNumber; }
    }
}
";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("ProtoContractAttribute.g.cs", SourceText.From(ProtoContractAttributeSource, Encoding.UTF8));
                ctx.AddSource("ProtoMemberAttribute.g.cs", SourceText.From(ProtoMemberAttributeSource, Encoding.UTF8));
            });

            var classDeclarations = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    "Protobuf.SourceGenerator.ProtoContractAttribute",
                    predicate: (node, _) => node is ClassDeclarationSyntax,
                    transform: (ctx, _) => GetClassInfo(ctx))
                .Where(m => m is not null);

            context.RegisterSourceOutput(classDeclarations, static (spc, classInfo) =>
            {
                if (classInfo is null) return;
                var source = GenerateSource(classInfo);
                spc.AddSource($"{classInfo.ClassName}.ProtoContract.g.cs", SourceText.From(source, Encoding.UTF8));
            });
        }

        private static ClassInfo? GetClassInfo(GeneratorAttributeSyntaxContext ctx)
        {
            if (ctx.TargetSymbol is not INamedTypeSymbol classSymbol) return null;

            var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : classSymbol.ContainingNamespace.ToDisplayString();

            var members = new List<ProtoMemberInfo>();

            foreach (var member in classSymbol.GetMembers())
            {
                if (member is not IPropertySymbol prop) continue;

                foreach (var attr in member.GetAttributes())
                {
                    if (attr.AttributeClass?.ToDisplayString() == "Protobuf.SourceGenerator.ProtoMemberAttribute")
                    {
                        if (attr.ConstructorArguments.Length > 0 &&
                            attr.ConstructorArguments[0].Value is int fieldNumber)
                        {
                            members.Add(new ProtoMemberInfo(fieldNumber, prop.Name, prop.Type));
                        }
                    }
                }
            }

            members.Sort((a, b) => a.FieldNumber.CompareTo(b.FieldNumber));

            return new ClassInfo(
                classSymbol.Name,
                namespaceName,
                members
            );
        }

        private static string GenerateSource(ClassInfo classInfo)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.IO;");
            sb.AppendLine();

            int indent = 0;

            if (classInfo.Namespace != null)
            {
                sb.AppendLine($"namespace {classInfo.Namespace}");
                sb.AppendLine("{");
                indent++;
            }

            string pad = new string(' ', indent * 4);

            sb.AppendLine($"{pad}partial class {classInfo.ClassName} : global::Protobuf.SourceGenerator.Runtime.IProtobufSerializable");
            sb.AppendLine($"{pad}{{");

            // WriteTo method
            sb.AppendLine($"{pad}    public void WriteTo(global::System.IO.Stream stream)");
            sb.AppendLine($"{pad}    {{");
            sb.AppendLine($"{pad}        var writer = new global::Protobuf.SourceGenerator.Runtime.ProtobufWriter(stream);");

            foreach (var member in classInfo.Members)
            {
                GenerateWriteStatement(sb, pad + "        ", member);
            }

            sb.AppendLine($"{pad}    }}");
            sb.AppendLine();

            // ParseFrom method
            sb.AppendLine($"{pad}    public static {classInfo.ClassName} ParseFrom(global::System.IO.Stream stream)");
            sb.AppendLine($"{pad}    {{");
            sb.AppendLine($"{pad}        var result = new {classInfo.ClassName}();");
            sb.AppendLine($"{pad}        var reader = new global::Protobuf.SourceGenerator.Runtime.ProtobufReader(stream);");
            sb.AppendLine($"{pad}        while (reader.MoveNext())");
            sb.AppendLine($"{pad}        {{");
            sb.AppendLine($"{pad}            switch (reader.FieldNumber)");
            sb.AppendLine($"{pad}            {{");

            foreach (var member in classInfo.Members)
            {
                GenerateReadCase(sb, pad + "                ", member);
            }

            sb.AppendLine($"{pad}                default: reader.SkipField(); break;");
            sb.AppendLine($"{pad}            }}");
            sb.AppendLine($"{pad}        }}");
            sb.AppendLine($"{pad}        return result;");
            sb.AppendLine($"{pad}    }}");

            sb.AppendLine($"{pad}}}");

            if (classInfo.Namespace != null)
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private static void GenerateWriteStatement(StringBuilder sb, string pad, ProtoMemberInfo member)
        {
            var typeName = member.Type.ToDisplayString();
            var memberName = member.Name;
            var fieldNum = member.FieldNumber;

            if (IsListType(member.Type, out var elementType))
            {
                var writeMethod = GetWriteRepeatedMethod(elementType!);
                if (writeMethod != null)
                {
                    sb.AppendLine($"{pad}if ({memberName} != null) writer.{writeMethod}({fieldNum}, {memberName});");
                }
                return;
            }

            switch (typeName)
            {
                case "int":
                    sb.AppendLine($"{pad}if ({memberName} != 0) writer.WriteInt32({fieldNum}, {memberName});");
                    break;
                case "int?":
                    sb.AppendLine($"{pad}if ({memberName}.HasValue && {memberName}.Value != 0) writer.WriteInt32({fieldNum}, {memberName}.Value);");
                    break;
                case "long":
                    sb.AppendLine($"{pad}if ({memberName} != 0L) writer.WriteInt64({fieldNum}, {memberName});");
                    break;
                case "long?":
                    sb.AppendLine($"{pad}if ({memberName}.HasValue && {memberName}.Value != 0L) writer.WriteInt64({fieldNum}, {memberName}.Value);");
                    break;
                case "bool":
                    sb.AppendLine($"{pad}if ({memberName}) writer.WriteBool({fieldNum}, {memberName});");
                    break;
                case "float":
                    sb.AppendLine($"{pad}if ({memberName} != 0f) writer.WriteFloat({fieldNum}, {memberName});");
                    break;
                case "double":
                    sb.AppendLine($"{pad}if ({memberName} != 0d) writer.WriteDouble({fieldNum}, {memberName});");
                    break;
                case "string":
                case "string?":
                    sb.AppendLine($"{pad}if ({memberName} != null) writer.WriteString({fieldNum}, {memberName});");
                    break;
                case "byte[]":
                case "byte[]?":
                    sb.AppendLine($"{pad}if ({memberName} != null) writer.WriteBytes({fieldNum}, {memberName});");
                    break;
                default:
                    if (IsProtoContractType(member.Type))
                    {
                        sb.AppendLine($"{pad}if ({memberName} != null) writer.WriteMessage({fieldNum}, {memberName});");
                    }
                    break;
            }
        }

        private static void GenerateReadCase(StringBuilder sb, string pad, ProtoMemberInfo member)
        {
            var typeName = member.Type.ToDisplayString();
            var memberName = member.Name;
            var fieldNum = member.FieldNumber;

            if (IsListType(member.Type, out var elementType))
            {
                var elementTypeName = elementType!.ToDisplayString();
                var readMethod = GetReadMethod(elementType!);
                if (readMethod != null)
                {
                    sb.AppendLine($"{pad}case {fieldNum}:");
                    sb.AppendLine($"{pad}    if (result.{memberName} == null) result.{memberName} = new global::System.Collections.Generic.List<{elementTypeName}>();");
                    if (IsProtoContractType(elementType!))
                    {
                        sb.AppendLine($"{pad}    result.{memberName}.Add(reader.ReadMessage({elementTypeName}.ParseFrom)); break;");
                    }
                    else
                    {
                        sb.AppendLine($"{pad}    result.{memberName}.Add(reader.{readMethod}()); break;");
                    }
                }
                return;
            }

            string readExpr;
            switch (typeName)
            {
                case "int":
                case "int?":
                    readExpr = "reader.ReadInt32()"; break;
                case "long":
                case "long?":
                    readExpr = "reader.ReadInt64()"; break;
                case "bool":
                    readExpr = "reader.ReadBool()"; break;
                case "float":
                    readExpr = "reader.ReadFloat()"; break;
                case "double":
                    readExpr = "reader.ReadDouble()"; break;
                case "string":
                case "string?":
                    readExpr = "reader.ReadString()"; break;
                case "byte[]":
                case "byte[]?":
                    readExpr = "reader.ReadBytes()"; break;
                default:
                    if (IsProtoContractType(member.Type))
                    {
                        readExpr = $"reader.ReadMessage({typeName}.ParseFrom)";
                    }
                    else
                    {
                        return; // unsupported type
                    }
                    break;
            }

            sb.AppendLine($"{pad}case {fieldNum}: result.{memberName} = {readExpr}; break;");
        }

        private static bool IsListType(ITypeSymbol type, out ITypeSymbol? elementType)
        {
            elementType = null;
            if (type is INamedTypeSymbol namedType &&
                namedType.IsGenericType)
            {
                var displayName = namedType.ConstructedFrom.ToDisplayString();
                if (displayName == "System.Collections.Generic.List<T>")
                {
                    elementType = namedType.TypeArguments[0];
                    return true;
                }
            }
            return false;
        }

        private static bool IsProtoContractType(ITypeSymbol type)
        {
            foreach (var attr in type.GetAttributes())
            {
                if (attr.AttributeClass?.ToDisplayString() == "Protobuf.SourceGenerator.ProtoContractAttribute")
                    return true;
            }
            return false;
        }

        private static string? GetWriteRepeatedMethod(ITypeSymbol elementType)
        {
            return elementType.ToDisplayString() switch
            {
                "int" => "WriteRepeatedInt32",
                "long" => "WriteRepeatedInt64",
                "bool" => "WriteRepeatedBool",
                "float" => "WriteRepeatedFloat",
                "double" => "WriteRepeatedDouble",
                "string" => "WriteRepeatedString",
                "byte[]" => "WriteRepeatedBytes",
                _ => IsProtoContractType(elementType) ? "WriteRepeatedMessage" : null
            };
        }

        private static string? GetReadMethod(ITypeSymbol elementType)
        {
            return elementType.ToDisplayString() switch
            {
                "int" => "ReadInt32",
                "long" => "ReadInt64",
                "bool" => "ReadBool",
                "float" => "ReadFloat",
                "double" => "ReadDouble",
                "string" => "ReadString",
                "byte[]" => "ReadBytes",
                _ => null
            };
        }
    }

    internal class ClassInfo
    {
        public string ClassName { get; }
        public string? Namespace { get; }
        public List<ProtoMemberInfo> Members { get; }

        public ClassInfo(string className, string? namespaceName, List<ProtoMemberInfo> members)
        {
            ClassName = className;
            Namespace = namespaceName;
            Members = members;
        }
    }

    internal class ProtoMemberInfo
    {
        public int FieldNumber { get; }
        public string Name { get; }
        public ITypeSymbol Type { get; }

        public ProtoMemberInfo(int fieldNumber, string name, ITypeSymbol type)
        {
            FieldNumber = fieldNumber;
            Name = name;
            Type = type;
        }
    }
}
